**ğŸ“ Input**: ` cat shivu/modules/info_ptb.py`

**ğŸ“’ Output **:
`from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, UserProfilePhotos
from telegram.ext import CommandHandler, CallbackQueryHandler, filters, MessageHandler, Updater
from shivu import collection, user_collection, event_collection, application
from shivu.modules.database.ban_user_db import is_user_banned
from shivu import user_badges
import os
import random


def generate_progress_bar(percent):
    filled_blocks = int(percent / 5)
    empty_blocks = 20 - filled_blocks
    return "â– " * filled_blocks + "â–¡" * empty_blocks



async def get_user_favorite_character_img_url(user_id: int) -> int:
    user = await user_collection.find_one({'id': user_id})
    if user and 'favorites' in user:
        favorite_id = user['favorites'][0]  # Assuming only one favorite character for simplicity
        favorite_character = next((c for c in user['characters'] if c['id'] == favorite_id), None)
        if favorite_character:
            return favorite_character['img_url']
    
    
    all_characters = user.get('characters', [])
    if all_characters:
        random_character = random.choice(all_characters)
        return random_character['img_url']
    
    return None
    



async def get_global_rank(username: str) -> int:
    pipeline = [
        {"$project": {"username": 1, "first_name": 1, "character_count": {"$size": "$characters"}}},
        {"$sort": {"character_count": -1}}
    ]

    cursor = user_collection.aggregate(pipeline)
    leaderboard_data = await cursor.to_list(length=None)

    for i, user in enumerate(leaderboard_data, start=1):
        if user.get('username') == username:
            return i

    return 0

async def count_winter_characters(user_id: int) -> int:
    user = await user_collection.find_one({'id': user_id})

    if user:
        winter_characters = [char for char in user.get('characters', []) if char.get('rarity') == 'â›„ Winters[S]']
        return len(winter_characters)

    return 0

async def get_user_async(user):
    pass

async def get_user_badges(user_id):
    user_badges_doc = await user_badges.find_one({'user_id': user_id})
    return user_badges_doc.get('badges', []) if user_badges_doc else []

async def get_user_info(user, already=False, update=None):
    if not already:
        # Assuming you have an async method to get users from the ID in the shivu library
        user = await get_user_async(user)
    if not update.effective_user.first_name:
        return ["Deleted account", None]
    user_id = update.effective_user.id
    
    if await is_user_banned(user_id):
        is_banned = "User is Banned for using the Bot"
    else:
        is_banned = "User is not Banned"
    
    username = update.effective_user.username
    first_name = update.effective_user.first_name
    userr = await user_collection.find_one({'id': user_id})
    if not userr:
        caught_characters = "Haven't caught any character"
        info_text = "Start Me And Secure Some Character's First"
    else:
        harem_user = await user_collection.find_one({'id': user_id})
        unique_characters = set()
        total_count = sum(1 for char in harem_user['characters'] if char.get('rarity') != 'â›„ï¸ Winters[S]' and (char_id := char.get('id')) not in unique_characters and not unique_characters.add(char_id))
        global_count = await collection.count_documents({})
        event_global_count = await event_collection.count_documents({})
        event_caught_characters = await count_winter_characters(user_id)
        total_percentage = min((total_count / global_count) * 100, 100)
        Rounded_total_percentage = round(total_percentage, 2)
        progress_bar = generate_progress_bar(Rounded_total_percentage)
        caught_characters = [f"{total_count}/{global_count}[{Rounded_total_percentage}%]"]
        global_rank = await get_global_rank(username)
        total_users = await user_collection.count_documents({})
        global_rank_ratio = f"{global_rank}/{total_users}"
        user_badge_list = await get_user_badges(user_id)
        badge_text = f"<b><a href='https://t.me/Catch_Emupdate/32'>ğŸ† Ê™á´€á´…É¢á´‡êœ±:</a></b> {' '.join(user_badge_list)}".strip() if user_badge_list else ""

        info_text = (
            f"<b>ğŸ“Š ğ—¨ğ˜€ğ—²ğ—¿'ğ˜€ ğ—£ğ—¿ğ—¼ğ—³ğ—¶ğ—¹ğ—²</b> â–°â–±â–°â–±â–°â–±â–°â–±â–°â–±â–°â–±â–°\n\n"
            f"<b>ğŸ†” Éªá´…:</b> {user_id}\n"
            f"<b>ğŸ“‘ É´á´€á´á´‡:</b> {first_name}\n"
            f"{badge_text}\n"
            f"<b>ğŸ”– á´œêœ±á´‡Ê€É´á´€á´á´‡:</b> @{username}\n"
            f"<b>â›©ï¸ á´„Êœá´€Ê€á´€á´„á´›á´‡Ê€êœ± á´„á´€á´œÉ¢Êœá´›:</b> {caught_characters[0]}\n"
            f"<b>ğŸ„ á´‡á´ á´‡É´á´› á´„Êœá´€Ê€á´€á´„á´›á´‡Ê€êœ±:</b> {event_caught_characters}/{event_global_count}\n"
            f"<b>ğŸ“ˆ á´˜Ê€á´É¢Ê€á´‡êœ±êœ± Ê™á´€Ê€:</b> {progress_bar}\n"
            f"<b>ğŸŒ É¢ÊŸá´Ê™á´€ÊŸ Ê€á´€É´á´‹:</b> {global_rank_ratio}\n"       
            f"<b>âš ï¸ Éªêœ± Ê™á´€É´É´á´‡á´…:</b> {is_banned}"       
        )
     
    return info_text

async def profile(update, context):
    bot = context.bot
    
    if update.message.reply_to_message:
        user = update.message.reply_to_message.from_user.id
        user_id = update.message.reply_to_message.from_user.id
    elif len(context.args) == 1:
        user = context.args[0]
        user_id = context.args[0]
    else:
        user = update.message.from_user.id
        user_id = update.effective_user.id
        
    m = await update.message.reply_text("Collecting User Data...")  # Use 'await' here
    
    try:
        info_text = await get_user_info(user, update=update)  # Use 'await' here
        fav_character_img_url = await get_user_favorite_character_img_url(user_id)
    except Exception as e:
        print(f"Something Went Wrong {e}")
        return await m.edit_text("Sorry something Went Wrong Report At @The_Catch_Squad")  # Use 'await' here

    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("sá´‡á´‡ á´„á´ÊŸÊŸá´‡á´„á´›Éªá´É´", switch_inline_query_current_chat=f"collection.{user}")],
        [InlineKeyboardButton("ğŸš®", callback_data="delete_message")]
    ])

    reply_markup = InlineKeyboardMarkup(
        [
            [InlineKeyboardButton("Start Me", url=f"https://t.me/{context.bot.username}?start=True")]
        ]
    )

    if info_text == "Start Me And Secure Some Character's First":
        return await m.edit_text(info_text, reply_markup=reply_markup)  # Use 'await' here
        
    if fav_character_img_url:
        await update.message.reply_photo(photo=fav_character_img_url, caption=info_text, parse_mode='HTML', reply_markup=keyboard)  # Use 'await' here
    else:
        await update.message.reply_text(info_text, parse_mode='HTML', reply_markup=keyboard, disable_web_page_preview=True)



async def callback_handler(update, context):
    if update.callback_query.data == "delete_message":
        await update.callback_query.message.delete()

application.add_handler(CommandHandler('profile', profile, block=False))
application.add_handler(CallbackQueryHandler(callback_handler, pattern='^delete_message', block=False))`